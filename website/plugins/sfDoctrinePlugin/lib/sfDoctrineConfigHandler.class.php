<?php

/**
 *
 * sfDoctrineConfigHandler parses the PHPDoctrine config file
 *
 * @package    symfony.plugins
 * @subpackage sfDoctrine
 * @author     Amadeus
 * @author     Olivier Verdier <Olivier.Verdier@gmail.com>
 * @author     Dan Porter
 * @version    SVN: $Id: sfDoctrineConfigHandler.class.php 4132 2007-05-31 19:50:01Z gnat $
 */
class sfDoctrineConfigHandler extends sfYamlConfigHandler
{
  public function execute($configFiles)
  {
    // Parse yaml config files
    $configs = $this->parseYamls($configFiles);

    // Default config: all.attributes
    $default_config = array ();
    if (isset ($configs['all']['attributes']) && is_array($configs['all']['attributes']))
    {
      $default_config = $configs['all']['attributes'];
      unset ($configs['all']['attributes']);
    }

    // Environment specific defaults: <env>.attributes
    $env = sfConfig::get('sf_environment');
    if (isset ($configs[$env]['attributes']) && is_array($configs[$env]['attributes']))
    {
      $default_config = sfToolKit::arrayDeepMerge($default_config, $configs[$env]['attributes']);
      unset ($configs[$env]['attributes']);
    }

    // Connection specific configs
    $conn_configs = array();
    foreach ($configs as $env => $env_config)
    {
      foreach ($env_config as $conn => $conn_config)
      {
        $conn_configs[$conn] = sfToolkit::arrayDeepMerge($default_config, $conn_config);
      }
    }
    
    // Prepare default config data
    $data = array();
    foreach ($this->configToAttributes($default_config) as $key => $value)
    {
      $data[] = sprintf('$default_attributes["%s"] = %s;', $key, $this->attributeToPhp($value));
    }
    $data[] = '';
    
    // Prepare connection specific data
    foreach ($conn_configs as $conn_name => $conn_config)
    {
      foreach ($this->configToAttributes($conn_config) as $key => $value)
      {
        $data[] = sprintf('$attributes["%s"]["%s"] = %s;', $conn_name, $key, $this->attributeToPHP($value));
      }
      $data[] = '';
    }

    // compile data
    $retval = sprintf("<?php\n" .
    "// auto-generated by sfDoctrineConfigHandler\n" .
    "// date: %s\n%s\n", date('Y-m-d H:i:s'), implode("\n", $data));

    return $retval;
  }

  protected function configToAttributes($config)
  {
    $attributes = array();
    foreach ($config as $key => $value)
    {
      $attr_key = 'ATTR_' . strtoupper($key);

      switch ($key)
      {
          // event listener (name of the listener class)
        case 'listener':
          $attributes[$attr_key] = array ('php', "new $value()");
          break;

        // fetch mode (immediate, batch, offset, lazy_offset)
        case 'fetchmode':
          $attributes[$attr_key] = array ('constant', 'FETCH_' . strtoupper($value));
          break;

          // locking (optimistic, pessimistic)
        case 'lockmode':
          $attributes[$attr_key] = array ('constant', 'LOCK_' . strtoupper($value));
          break;

          // export (none, tables, constraints, all)
          case 'export':
            $attributes[$attr_key] = array('constant', 'EXPORT_'.strtoupper($value));
            break;

          // accessors (none, get, set, both)
/*        case 'accessors':
          $attributes[$attr_key] = array ('constant', 'ACCESSOR_' . strtoupper($value));
          break;
*/
          // portability (none, fix_case, rtrim, delete_count, empty_to_null, fix_assoc_field_names, all)
        case 'portability':
          $attributes[$attr_key] = array ('constant', 'PORTABILITY_' . strtoupper($value));
          break;

        // the default will set the value as a string or a boolean (depending on the type returned by the yaml parser)
        default:
          $attributes[$attr_key] = $value;
      }
    }
    return $attributes;
  }
  
  protected function attributeToPhp($attr)
  {
    if (is_array($attr))
    {
      if ($attr[0] == 'constant')
      {
        $attr = 'Doctrine::' . $attr[1];
      }
      elseif ($attr[0] == 'php')
      {
        $attr = $attr[1];
      }
    }
    elseif (is_string($attr))
    {
      $attr = sprintf("'%s'", $attr);
    }
    else
    {
      $attr = var_export($attr, 1);
    }
    return $attr;
  }
}
