++ 要件
DoctrineはPHPの5.2以降を要求します。外部のライブラリは要求されません。データベースの関数コールの抽象化のためにDoctrineはデフォルトでPHPにバンドルされているPDOを使用します。

++ インストレーション
Doctrineの導入はとても簡単です。http://doctrine.pengus.net/svn/trunk から最新のDoctrineのリビジョンを入手するだけです。

DoctrineをダウンロードするためにSVN (Subversion)クライアントが必要です。

現在のディレクトリでDoctrineをチェックアウトするために**svn**コマンドラインは次のコードを使用します: 

<code type="bash">
svn co http://doctrine.pengus.net/svn/trunk . 
</code>

SVNクライアントがない場合、下記のリストから一つ選んで下さい。**チェックアウト**、**パス**、**リポジトリURL**オプションを見つけて http://doctrine.pengus.net/svn/trunk を入力して下さい。Doctrineをチェックアウトするためにユーザー名もしくはパスワードは必要ありません。

* [http://tortoisesvn.tigris.org/ TortoiseSVN]はWindows Explorerに統合されるWindowsアプリケーションです
* [http://www.apple.com/downloads/macosx/development_tools/svnx.html svnx]はMac OS X GUI svnアプリケーションです 
* Eclipseは[http://subclipse.tigris.org/ subeclipse]プラグインを通してSVNと統合します

++ 新しいプロジェクトを始める
Doctrine_RecordはすべてのDoctrineベースプロジェクトの基本コンポーネントです。少なくともそれぞれのデータベーステーブルに対してDoctrine_Recordが一つあります。Doctrine_Record follows the [http://www.martinfowler.com/eaaCatalog/activeRecord.html Active Record pattern]

Doctrineは常に主キーを持たないテーブルに対して'id'という名前の主キーを追加します。データベースのテーブルを作成するために必要な唯一のことはDoctrine_Recordを拡張するクラスを定義しhasColumn()メソッドコールを持ちこれらのクラスをエクスポートすることでsetTableDefinitionメソッドを設定することです。

'user'というデータベーステーブルを作成することを考えてみます。カラムはid(primary key)、name、username、passwordとcreatedです。Doctrineが既にインストールされているとして必要なものは下記の数行です:

User.php :
<code type="php">
class User extends Doctrine_Record 
{
    public function setTableDefinition() 
    {
        // 'user'テーブルカラムを設定する
        // idカラムはオートインクリメントで主キーは指定されていないことに注意
        
        $this->hasColumn('name', 'string',30);
        $this->hasColumn('username', 'string',20);
        $this->hasColumn('password', 'string',16);
        $this->hasColumn('created', 'integer',11);
    }
}
</code>

ユーザークラスをデータベースにエクスポートするために次のシンプルなビルドスクリプトが必要です:

<code type="php">
//ベースのDoctrineクラスをrequireする
require_once('lib/Doctrine.php');

//autoloaderを登録する
spl_autoload_register(array('Doctrine', 'autoload'));

require_once('User.php');

//接続をセットアップする
Doctrine_Manager::connection('mysql://user:pass@localhost/test');

//クラスをエクスポートする
Doctrine::createTablesFromArray(array('User'));
</code>
これで基本的なCRUOオペレーションをサポートするユーザーモデルができました！


++ 既存のデータベースと連携する
+++ 導入

DoctrineのようなORMツールを探すときに共通の事例はデータベースとコードが肥大/複雑になることです。SQLコードを操作するためによりしっかりしたツールが必要とされます。 

Doctrineは既存のデータベースからDoctrine_Recordクラスの生成をサポートします。ドメインモデルに対してすべてのDoctrine_Recordクラスを手動で書く必要はありません。 

+++ 最初のインポートを作成する

'file'という名前の一つのテーブルを持つtestというMySQLのデータベースを考えてみましょう。

fileテーブルは次のSQL命令文で作成されました:

<code type="sql">
CREATE TABLE file (
    id INT UNSIGNED AUTO_INCREMENT NOT NULL,
    name VARCHAR(150),
    size BIGINT,
    modified BIGINT,
    type VARCHAR(10),
    content TEXT,
    path TEXT,
    PRIMARY KEY(id))
</code>

これをDoctrine_Recordクラスに変換することを考えます。これは次のコードスニペットで簡単に達成できます:

<code type="php">
require_once('lib/Doctrine.php');

spl_autoload_register(array('Doctrine', 'autoload'));
Doctrine_Manager::connection('mysql://root:dc34@localhost/test');

// インポートメソッドは一つのパラメータを取ります: importディレクトリ
// (生成されたレコードファイルが設置されるディレクトリ)
Doctrine::generateModelsFromDb('myrecords');
</code>

お終いです！myrecordsディレクトリでFile.phpという名前のファイルが存在します。ファイルは次の通りです:

<code type="php">
/**
 * This class has been auto-generated by the Doctrine ORM Framework
 * Created: Saturday 10th of February 2007 01:03:15 PM
 */
class File extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('id', 'integer', 4, array('notnull' => true,
                                                   'primary' => true,
                                                   'unsigned' => true,
                                                   'autoincrement' => true));
        $this->hasColumn('name', 'string', 150);
        $this->hasColumn('size', 'integer', 8);
        $this->hasColumn('modified', 'integer', 8);
        $this->hasColumn('type', 'string', 10);
        $this->hasColumn('content', 'string', null);
        $this->hasColumn('path', 'string', null);
    }
    public function setUp()
    {

    }
}
</code>

+++ インポートオプション


++ クラスをエクスポートする
+++ 導入

Doctrineはレコードクラスをデータベースにエクスポートすることをサポートします。レコード定義に与えられた定義に基づいてDoctrineはデータベーススキーマを変更します。

次の定義を持つUserとPhonenumberという名前のクラスを考えます:

<code type="php">
// User.phpファイル
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string', 20);
    }
    public function setUp()
    {
        $this->hasMany('Phonenumber', array('local' => 'id',
                                            'foreign' => 'user_id'));
    }
}
// Phonenumber.phpファイル
class Phonenumber extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('phonenumber', 'string', 20);
        $this->hasColumn('user_id', 'integer');
    }
    public function setUp()
    {
        $this->hasOne('User', array('local' => 'user_id',
                                    'foreign' => 'id',
                                    'onDelete' => 'CASCADE'));
    }
}
</code>

これらのクラスは'models/'ディレクトリにあります。このディレクトリをイテレートしてこれらのクラスを以下のスクリプトを持ったデータベース構造に追加します:

<code type="php">

require_once('path-to-doctrine/lib/Doctrine.php');

spl_autoload_register(array('Doctrine', 'autoload'));

//エクスポートするためにデータベース接続が必要である
Doctrine_Manager::connection('mysql://user:pass@localhost/test');

Doctrine::createTablesFromModels('models');
</code>

これはMySQL上で次のクエリーを実行します。

<code type="sql">
CREATE TABLE user (id BIGINT AUTO_INCREMENT, name VARCHAR(20), PRIMARY KEY(id), INDEX(id));
CREATE TABLE phonenumber (id INT AUTO_INCREMENT, phonenumber VARCHAR(20), user_id BIGINT, PRIMARY KEY(id), INDEX(user_id));
ALTER TABLE phonenumber ADD CONSTRAINT FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE;
</code>

次のことに注意を払います:

# 主キーカラムを指定していないのでオートインクリメントの主キーが自動追加されます
# Doctrineはインデックスを参照された関連カラムに自動追加します(これはMySQLに必要です)

+++ エクスポートクエリーを手に入れる

エクスポートクエリーをすぐに実行を行いたくなくむしろクエリーの文字列を入手してそれらをbuild.sqlファイルに添付したい状況があるとします。これは次のように達成できます:

<code type="php">
require_once('path-to-doctrine/lib/Doctrine.php');

spl_autoload_register(array('Doctrine', 'autoload'));

Doctrine_Manager::connection('mgsql://user:pass@localhost/test');

$queries = Doctrine::generateSqlFromModels('models');

echo $queries;
</code>

同じ状況を考えてエクスポートを実行するために必要なSQLクエリーの文字を取得したいことを考えます。Doctrine::generateSqlFromModels()で実現されました。

+++ エクスポートオプション

<code type="php">
// テーブル定義と制約などのすべてをエクスポートする
$manager = Doctrine_Manager::getInstance();

$manager->setAttribute(Doctrine::ATTR_EXPORT, Doctrine::EXPORT_ALL);

// 制約無しでクラスをエクスポートする

$manager->setAttribute(Doctrine::ATTR_EXPORT, Doctrine::EXPORT_TABLES ^ 
                                              Doctrine::EXPORT_CONSTRAINTS);

// エクスポーティングをオフにする

$manager->setAttribute(Doctrine::ATTR_EXPORT, Doctrine::EXPORT_NONE);

$sql = Doctrine::generateSqlFromModels();
</code>
