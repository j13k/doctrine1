++ 動作条件
Doctrineを動作させるにはPHPの5.2.3以降が必要です。外部のライブラリは必要ありません。データベースの関数コールの抽象化のためにDoctrineはデフォルトでwww.php.netにある正式版にPHPにバンドルされているPDOを使用します。Windows用のUniform Serverなど正式版でないパッケージからPHPをインストールした場合、追加の設定を行う必要があるかもしれません。

++ インストール

Doctrineをインストールするのは４つの方法があります。

* SVN (subversion)
* 外部 SVN (SVN externals)
* Pear
* Zipパッケージ

DoctrineをSVN (subversion) 経由でダウンロードすることをおすすめします。この方法が一番更新のやりやすい方法です。あなたのプロジェクトが既にSVNで管理されている場合はSVN externalsを使うべきでしょう。

Doctrineを5分で使いたい方はsandboxパッケージからインストールするのがいいでしょう。

+++ Sandboxパッケージ

Doctrineを使うために全く設定を必要としないパッケージを用意しました。これには全機能を備えたコマンドラインのインターフェースが含まれ、それを使ってスキーマのファイル、migrationのファイル、データベースへの接続、データフィクスチャやその他の機能を操作することができます。sandboxパッケージの詳細は [doc utilities :name] 章のSandboxの節を参照してください。

以下にあるURLにsandboxパッケージを使ってDoctrineを使い始めるチュートリアルがあります。sandboxとこのチュートリアルを使ってDoctrineを５分以内で使えるようになるでしょう。このチュートリアルにはスキーマファイル、データフィクスチャ、UserモデルをDoctrineを使って操作する例があります。シンプルな生成、更新、削除の機能など。

このチュートリアルは http://trac.phpdoctrine.org/wiki/MyFirstProject にあり、sandboxパッケージは http://www.phpdoctrine.org/download からダウンロード可能です。

+++ SVN

Doctrineの導入はとても簡単です。http://svn.phpdoctrine.org/branches/0.10 から最新のDoctrineのリビジョンを入手するだけです。

コマンドラインからDoctrineをチェックアウトするには以下のコマンドを入力してください。

<code type="bash">
svn co http://svn.phpdoctrine.org/branches/0.10 .
</code>

SVNクライアントがない場合、下記のリストから一つ選んで下さい。**チェックアウト**　オプションを見つけて、その中の **パス** や **リポジトリURL** パラメータ内に svn.phpdoctrine.org/branches/0.10 を入力して下さい。Doctrineをチェックアウトするためにユーザー名もしくはパスワードは必要ありません。

* [http://tortoisesvn.tigris.org/ TortoiseSVN]はWindows Explorerに統合されるWindowsアプリケーションです
* [http://www.apple.com/downloads/macosx/development_tools/svnx.html svnx]はMac OS X GUI svnアプリケーションです 
* Eclipseは[http://subclipse.tigris.org/ subeclipse]プラグインを通してSVNと統合します

最新版にするにはDoctrineの入っているディレクトリ内で以下のコマンドを使ってください

<code type="bash">
svn update
</code>

+++ SVN externals

既にSVNでバージョン管理をしているディレクトリの中にDoctrineをインストールする場合、svn externalsを使うべきです。以下の **svn** のコマンドでそれを行います

<code type="bash"> 
svn pe svn:externals /path/to/project
</code>

以下の行をエディタを使って追加して保存します。

<code>
doctrine http://svn.phpdoctrine.org/branches/0.10
</code>

その後にDoctineをダウンロードします

<code>
doctrine http://svn.phpdoctrine.org/branches/0.10
</code>

+++ PEAR

PEARを使ってDoctrineをインストールするには以下のコマンドを使います

<code>
doctrine http://svn.phpdoctrine.org/branches/0.10
</code>

+++ Zipパッケージ

Doctrineを.zip や.tgz (Linux用)パッケージで http://www.phpdoctrine.org/download からダウンロード可能です。
ただ単にパッケージをプロジェクトディレクトリ内に展開して使います。

Linuxの場合 .tgz パッケージをダウンロードして以下のコマンドで展開してください。

<code type="bash"> 
tar xzf Doctrine-0.10.1.tgz
</code>

++ 新しいプロジェクトを始める

Doctrine_RecordはすべてのDoctrineを使ったプロジェクトの基本コンポーネントになります。少なくともそれぞれのデータベーステーブルに対してDoctrine_Recordが一つあります。Doctrine_Record は [http://www.martinfowler.com/eaaCatalog/activeRecord.html Active Record pattern] のパターンを継承しています。

Doctrineは常に主キーを持たないテーブルに対して'id'という名前の主キーを追加します。Doctrine_Record を継承してsetTableDefinitionメソッドをhasColumn()で定義してそれらのクラスをエクスポートするだけでデータベースのテーブルが作成されます。

'user'というデータベーステーブルを作成することを考えてみます。カラムはid(primary key)、name、username、passwordとcreatedです。Doctrineが既にインストールされているとして、必要なものは下記の数行です:

User.php :
<code type="php">
class User extends Doctrine_Record 
{
    public function setTableDefinition() 
    {
        // set 'user' table columns, note that
        // id column is auto-created as no primary key is specified
        
        $this->hasColumn('name', 'string',30);
        $this->hasColumn('username', 'string',20);
        $this->hasColumn('password', 'string',16);
    }
    
    public function setUp()
    {
        $this->actAs('Timestampable');
    }
}
</code>

この代わりにYAMLスキーマを使ってDoctrineのスキーマ情報を指定することも可能です。以下がDoctrine_Recordから生成するためのuser.ymlの例です

<code type="yml">
---
User:
  actAs: [Timestampable]
  columns:
    name: string(30)
    username: string(20)
    password: string(16)
</code>

以下のコマンドを走らせてyamlからphpこーどを生成することができます

<code type="php">
Doctrine::generateModelsFromYaml('/path/to/user.yml', '/path/to/generate/models);
</code>

パス /path/to/generate/models/ か /path/to/generate/models/generated を見てください。ここにUser.phpとBaseUser.phpがあるはずです。User.phpにこーどを追加することで任意の機能を追加することができます。まだBaseUser.phpにはYAMLスキーマファイルから毎回生成されます。

これでDoctrine_Recordクラスが使えるようになりました、ここからデータベースにエクスポートしたり、テーブルを作成したりできます。上のUserクラスをデータベースにエクスポートするために次のシンプルなビルドスクリプトを使います：

<code type="php">
//Doctrineのベースクラスを読み込む
require_once('path-to-doctrine/lib/Doctrine.php');

//autoloaderの登録
spl_autoload_register(array('Doctrine', 'autoload'));

require_once('User.php');

//接続のセットアップ
Doctrine_Manager::connection('mysql://user:pass@localhost/test');

//クラスのエクスポート
Doctrine::createTablesFromArray(array('User'));
</code>

これで基本的なCRUDオペレーションをサポートするUserモデルが使えるようになりました！

++ 既存のデータベースと連携する

+++ はじめに

DoctrineのようなORMツールを使ってよく起こることはデータベースとコードが肥大/複雑になることです。SQLを直書きするより、よいツールが必要です。

Doctrineは既存のデータベースからDoctrine_Recordクラスの生成をサポートします。ドメインモデルに対してすべてのDoctrine_Recordクラスを一から書く必要はありません。 

+++ 最初のインポートを作成する

'file'という名前の一つのテーブルを持つtestというMySQLのデータベースを考えてみましょう。

fileテーブルは次のSQL命令文で作成されました:

<code type="sql">
CREATE TABLE file (
    id INT UNSIGNED AUTO_INCREMENT NOT NULL,
    name VARCHAR(150),
    size BIGINT,
    modified BIGINT,
    type VARCHAR(10),
    content TEXT,
    path TEXT,
    PRIMARY KEY(id))
</code>

これをDoctrine_Recordクラスに変換することを考えます。これは次のコードを使って簡単にできます：

<code type="php">
require_once('path-to-doctrine/lib/Doctrine.php');

spl_autoload_register(array('Doctrine', 'autoload'));
Doctrine_Manager::connection('mysql://root:dc34@localhost/test');

// インポートメソッドはインポートディレクトの入ったパラメータを１つとります。
//インポートディレクトリには生成されたファイルが保存されます。
Doctrine::generateModelsFromDb('myrecords');
</code>


これでおしまいです！myrecords/generatedディレクトリ以下にでFile.phpという名前のファイルが保存されました。ファイルの内容は以下の通りです:

<code type="php">
/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
abstract class BaseFile extends Doctrine_Record
{

  public function setTableDefinition()
  {
    $this->setTableName('file');
    $this->hasColumn('id', 'integer', 4, array('unsigned' => 1, 'values' =>  array(), 'primary' => true, 'notnull' => true, 'autoincrement' => true));
    $this->hasColumn('name', 'string', 150, array('fixed' => false, 'values' =>  array(), 'primary' => false, 'notnull' => false, 'autoincrement' => false));
    $this->hasColumn('size', 'integer', 8, array('unsigned' => 0, 'values' =>  array(), 'primary' => false, 'notnull' => false, 'autoincrement' => false));
    $this->hasColumn('modified', 'integer', 8, array('unsigned' => 0, 'values' =>  array(), 'primary' => false, 'notnull' => false, 'autoincrement' => false));
    $this->hasColumn('type', 'string', 10, array('fixed' => false, 'values' =>  array(), 'primary' => false, 'notnull' => false, 'autoincrement' => false));
    $this->hasColumn('content', 'string', null, array('fixed' => false, 'values' =>  array(), 'primary' => false, 'notnull' => false, 'autoincrement' => false));
    $this->hasColumn('path', 'string', null, array('fixed' => false, 'values' =>  array(), 'primary' => false, 'notnull' => false, 'autoincrement' => false));
  }

  public function setUp()
  {
    parent::setUp();
  }

}
</code>

またFile.phpというファイルがmyrecordsディレクトリ内に保存されています。ファイルの内容は以下の通り：


<code type="php">
/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class FileTable extends Doctrine_Table
{



}
</code>

ここにカスタムメソッドを追加してDoctrine::getTable('User')を使って呼ぶことができます。

+++ インポートの際のテーブル名の単数形化

デフォルトではDoctrineは既存のデータベースから読み込まれた各モデルの名前を単数型にしようとします。この機能を望まない方は以下の方法で簡単にoffにしてください

<code type="php">
Doctrine_Manager::getInstance()->setAttribute('singularize_import', false);
</code>

これで"files"というテーブル名からは"File.php"というモデルは無く、"Files.php"というモデルが生成されます。

++ テーブルの作成

+++ はじめに

Doctrineはレコードクラスをデータベースにエクスポートすることをサポートします。レコードクラスにある定義からDoctrineがデータベース内にテーブルを作ります。

次の定義を持つUserとPhonenumberという名前のクラスを考えます:

<code type="php">
// file User.php
class User extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('name', 'string', 20);
    }
    public function setUp()
    {
        $this->hasMany('Phonenumber', array('local' => 'id',
                                            'foreign' => 'user_id'));
    }
}
// file Phonenumber.php
class Phonenumber extends Doctrine_Record
{
    public function setTableDefinition()
    {
        $this->hasColumn('phonenumber', 'string', 20);
        $this->hasColumn('user_id', 'integer');
    }
    public function setUp()
    {
        $this->hasOne('User', array('local' => 'user_id',
                                    'foreign' => 'id',
                                    'onDelete' => 'CASCADE'));
    }
}
</code>

これらのクラスは'models/'ディレクトリにあるとします。このディレクトリの中をDoctrineに回遊させて、以下のスクリプトを使って各クラスをデータベース構造に追加します:

<code type="php">

require_once('path-to-doctrine/lib/Doctrine.php');

spl_autoload_register(array('Doctrine', 'autoload'));

//エクスポートするためにデータベース接続が必要
Doctrine_Manager::connection('mysql://user:pass@localhost/test');

Doctrine::createTablesFromModels('models');
</code>

これはMySQL上で次のクエリーを実行します。

<code type="sql">
CREATE TABLE user (id BIGINT AUTO_INCREMENT, name VARCHAR(20), PRIMARY KEY(id), INDEX(id));
CREATE TABLE phonenumber (id INT AUTO_INCREMENT, phonenumber VARCHAR(20), user_id BIGINT, PRIMARY KEY(id), INDEX(user_id));
ALTER TABLE phonenumber ADD CONSTRAINT FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE;
</code>

以下の点に注意してください:

# 主キーカラムを指定していないのでオートインクリメントの主キーが自動追加されます
# Doctrineはインデックスを参照された関連カラムに自動追加します(これはMySQLが必要とします)

+++ エクスポートクエリーを手に入れる

エクスポートクエリーをすぐに実行するのではなく、クエリーの文字列を入手してそれらをbuild.sqlファイルに保存したい状況があるとします。これは次のように達成できます:

<code type="php">
require_once('path-to-doctrine/lib/Doctrine.php');

spl_autoload_register(array('Doctrine', 'autoload'));

Doctrine_Manager::connection('mgsql://user:pass@localhost/test');

$queries = Doctrine::generateSqlFromModels('models');

echo $queries;
</code>

同じ様にエクスポートを実行するために必要なSQLクエリーの文字を取得したい場合は Doctrine::generateSqlFromModels() を使います。

+++ エクスポートオプション

<code type="php">
// テーブル定義と制約などのすべてをエクスポートする
$manager = Doctrine_Manager::getInstance();

$manager->setAttribute(Doctrine::ATTR_EXPORT, Doctrine::EXPORT_ALL);

// 制約無しでクラスをエクスポートする

$manager->setAttribute(Doctrine::ATTR_EXPORT, Doctrine::EXPORT_TABLES ^ 
                                              Doctrine::EXPORT_CONSTRAINTS);

//エクスポートをoffにする

$manager->setAttribute(Doctrine::ATTR_EXPORT, Doctrine::EXPORT_NONE);

$sql = Doctrine::generateSqlFromModels();
</code>

++ モデルの生成

Doctrineは既存のデータベースやYAMLスキーマファイルからからモデルを生成することができます。既存のデータベースからモデルを生成する方法は [doc getting-started:既存のデータベースと連携する :index :name] の節で紹介しました。

以下がYAMLスキーマファイルからモデルを生成している例です：

schema_files/user.yml ファイルを作り、以下のyamlを記述します
<code type="yaml">
---
User:
  columns:
    username: string(255)
    password: string(255)
</code>

そしてDoctrine_Recordの定義を生成する小さなスクリプトを使います
<code type="php">
require_once('/path/to/Doctrine.php');
spl_autoload_register(array('Doctrine', 'autoload'));

Doctrine::generateModelsFromYaml('/path/to/schema_files/', '/path/to/generate/models');
</code>

そして models/User.php と models/generated/BaseUser.php ファイルが保存されます。User.phpにカスタムコードを入れるためのもので、一度だけ生成されます。そしてBaseUser.phpはgenerateModelsFromYaml() が呼ばれる度に生成されます。

++ Auto loading models
++ Command line interface
++ My first project tutorial
