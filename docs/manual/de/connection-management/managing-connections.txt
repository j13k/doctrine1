Von Beginn an wurde Doctrine so entworfen, dass es mit mehreren DB-Verbindungen arbeitet. Außer Sie geben die Verbindung explizit an, benutzt Doctrine immer die dezeit aktuelle Verbindung für Anfragen. 
Das folgende Bespiel zeigt, wie man eine optionale DB-Verbindung als 2. Funktionsparameter {{openConnection()}} übergibt:

<code type="php">
// Doctrine_Manager verwaltet alle Verbindungen

$manager = Doctrine_Manager::getInstance();

// erste Verbindung öffnen
 
$conn = $manager->openConnection('mysql://username:password@localhost/test', 'connection 1');
</code>

Zur Vereinfachung stellt {{Doctrine_Manager}} die statische Methode {{connection()}} bereit. Beim Aufruf mit Parametern öffnet sie eine neue Verbindung, ohne Parameter liefert sie die aktuelle Vebindung zurück.

<code type="php">
// erste Verbindung öffnen
 
$conn = Doctrine_Manager::connection('mysql://username:password@localhost/test', 'connection 1');

$conn2 = Doctrine_Manager::connection();

// $conn2 == $conn
</code>

Die aktuelle Verbindung ist immer die zuletzt geöffnete.


<code type="php">
// zweite Verbindung öffnen

$conn2 = $manager->openConnection('mysql://username2:password2@localhost/test2', 'connection 2');

$manager->getCurrentConnection(); // $conn2
</code>

Ändern Sie die benutzte Verbindung durch Aufrufen von {{setCurrentConnection()}}.
<code type="php">
$manager->setCurrentConnection('connection 1');

$manager->getCurrentConnection(); // $conn
</code>


Da {{Doctrine_Manager}} das {{IteratorAggregate}} Interface implementiert, können sie ganz einfach mit foreach über das Manager Objekt iterieren, um auf die geöffneten Verbindungen zuzugreifen:

<code type="php">
// iterating through connections

foreach($manager as $conn) {

}
</code>